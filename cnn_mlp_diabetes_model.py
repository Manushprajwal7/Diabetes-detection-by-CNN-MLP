# -*- coding: utf-8 -*-
"""cnn_mlp_diabetes_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LP1BOS2DcRIrSy7UuGExfV3gSVshfhGm
"""

from google.colab import drive
drive.mount('/content/drive')

import glob

# Change paths if your folder structure is different
control_files = glob.glob('/content/drive/MyDrive/plantar_data/Control/*.xlsx')
diabetic_files = glob.glob('/content/drive/MyDrive/plantar_data/Diabetes/*.xlsx')

print(f"Found {len(control_files)} control files and {len(diabetic_files)} diabetic files.")

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler

# Load only numeric data (removing metadata/timestamps)
def load_excel(file):
    df = pd.read_excel(file, engine='openpyxl')
    df = df.select_dtypes(include=[np.number])  # Keep only numeric columns
    df = df.fillna(0)  # Replace missing values
    return df.to_numpy()

# Normalize and label data
def preprocess(files, label):
    data = []
    labels = []
    for file in files:
        matrix = load_excel(file)
        if matrix.size == 0:
            continue
        matrix = MinMaxScaler().fit_transform(matrix)
        data.append(matrix)
        labels.append(label)
    return data, labels

# Apply preprocessing to both groups
control_data, control_labels = preprocess(control_files, 0)
diabetic_data, diabetic_labels = preprocess(diabetic_files, 1)

from tensorflow.keras.preprocessing.sequence import pad_sequences

# Combine data and labels
X_combined = np.array(control_data + diabetic_data, dtype=object)
y_combined = np.array(control_labels + diabetic_labels)

# Determine max matrix size for padding
max_rows = max([m.shape[0] for m in X_combined])
max_cols = max([m.shape[1] for m in X_combined])

# Pad matrices to same shape
X_padded = np.array([
    np.pad(m, ((0, max_rows - m.shape[0]), (0, max_cols - m.shape[1])), mode='constant')
    for m in X_combined
])

# Add channel dimension for CNN
X_padded = X_padded[..., np.newaxis]  # Shape: (samples, rows, cols, 1)

# Generate dummy MLP metadata (replace later with real patient data)
mlp_metadata = np.random.rand(len(X_padded), 5)

from sklearn.model_selection import train_test_split

X_train, X_test, meta_train, meta_test, y_train, y_test = train_test_split(
    X_padded, mlp_metadata, y_combined, test_size=0.2, random_state=42, stratify=y_combined
)

import tensorflow as tf
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Dropout, concatenate

# CNN input for pressure matrix
input_cnn = Input(shape=(X_padded.shape[1], X_padded.shape[2], 1), name='cnn_input')
x = Conv2D(32, (3, 3), activation='relu')(input_cnn)
x = MaxPooling2D((2, 2))(x)
x = Conv2D(64, (3, 3), activation='relu')(x)
x = Flatten()(x)

# MLP input for patient metadata
input_mlp = Input(shape=(5,), name='mlp_input')
y = Dense(32, activation='relu')(input_mlp)
y = Dropout(0.3)(y)

# Combine both
combined = concatenate([x, y])
z = Dense(64, activation='relu')(combined)
z = Dropout(0.5)(z)
z = Dense(1, activation='sigmoid')(z)

# Final model
model = Model(inputs=[input_cnn, input_mlp], outputs=z)
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.summary()

history = model.fit(
    [X_train, meta_train],
    y_train,
    validation_split=0.15,
    epochs=20,
    batch_size=16,
    verbose=1
)

from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# Predict
y_pred = model.predict([X_test, meta_test]) > 0.5

# Report
print(classification_report(y_test, y_pred))

# Confusion matrix
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix')
plt.show()

from sklearn.metrics import roc_curve, auc

probs = model.predict([X_test, meta_test])
fpr, tpr, _ = roc_curve(y_test, probs)
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', label=f'ROC AUC = {roc_auc:.2f}')
plt.plot([0, 1], [0, 1], linestyle='--', color='gray')
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend()
plt.show()

model.save('cnn_mlp_diabetes_model.keras')